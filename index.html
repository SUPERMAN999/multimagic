<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1e293b">
    <title>GENIUS Matrix - EN+RO Dual Mobile</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
        }
        * {
            -webkit-tap-highlight-color: transparent;
        }
        .translating {
            opacity: 0.6;
        }
        .dragging {
            opacity: 0.5;
        }
        .drag-over {
            background-color: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6 !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // EXPANDED DICTIONARY - Same as desktop
        const dictionary = {
            'en_to_ro': {
                // Work related
                'meeting': '√Ænt√¢lnire',
                'call': 'sunƒÉ',
                'email': 'email',
                'send email': 'trimite email',
                'urgent': 'urgent',
                'important': 'important',
                'deadline': 'termen limitƒÉ',
                'project': 'proiect',
                'task': 'sarcinƒÉ',
                'work': 'muncƒÉ',
                'report': 'raport',
                'presentation': 'prezentare',
                'review': 'revizuire',
                'approve': 'aprobare',
                'complete': 'completeazƒÉ',
                'finish': 'terminƒÉ',
                'start': '√Æncepe',
                'schedule': 'programeazƒÉ',
                'plan': 'planificƒÉ',
                'organize': 'organizeazƒÉ',
                'prepare': 'pregƒÉte»ôte',
                'submit': 'trimite',
                'file': 'fi»ôier',
                'document': 'document',
                'contract': 'contract',
                'invoice': 'facturƒÉ',
                'budget': 'buget',
                'expense': 'cheltuialƒÉ',
                'proposal': 'propunere',
                'strategy': 'strategie',
                'analysis': 'analizƒÉ',
                
                // Personal tasks
                'buy groceries': 'cumpƒÉrƒÉ alimente',
                'groceries': 'alimente',
                'shopping': 'cumpƒÉrƒÉturi',
                'buy': 'cumpƒÉrƒÉ',
                'sell': 'vinde',
                'pay': 'plƒÉte»ôte',
                'pay bills': 'plƒÉte»ôte facturile',
                'bills': 'facturi',
                'home': 'acasƒÉ',
                'family': 'familie',
                'kids': 'copii',
                'children': 'copii',
                'school': '»ôcoalƒÉ',
                'homework': 'temƒÉ',
                'clean': 'curƒÉ»õƒÉ',
                'laundry': 'rufe',
                'cook': 'gƒÉte»ôte',
                'dinner': 'cinƒÉ',
                'lunch': 'pr√¢nz',
                'breakfast': 'micul dejun',
                
                // Health & appointments
                'call doctor': 'sunƒÉ doctorul',
                'call the doctor': 'sunƒÉ doctorul',
                'go to the doctor': 'du-te la doctor',
                'go to doctor': 'du-te la doctor',
                'see the doctor': 'vezi doctorul',
                'visit doctor': 'viziteazƒÉ doctorul',
                'doctor': 'doctor',
                'dentist': 'dentist',
                'appointment': 'programare',
                'hospital': 'spital',
                'pharmacy': 'farmacie',
                'medicine': 'medicament',
                'exercise': 'exerci»õiu',
                'workout': 'antrenament',
                'gym': 'salƒÉ',
                'health': 'sƒÉnƒÉtate',
                
                // Communication
                'call mom': 'sunƒÉ mama',
                'call dad': 'sunƒÉ tata',
                'text': 'mesaj',
                'message': 'mesaj',
                'reply': 'rƒÉspunde',
                'respond': 'rƒÉspunde',
                'contact': 'contacteazƒÉ',
                'phone': 'telefon',
                
                // Actions
                'fix': 'reparƒÉ',
                'repair': 'reparƒÉ',
                'update': 'actualizeazƒÉ',
                'cancel': 'anuleazƒÉ',
                'confirm': 'confirmƒÉ',
                'book': 'rezervƒÉ',
                'reserve': 'rezervƒÉ',
                'order': 'comandƒÉ',
                'return': 'returneazƒÉ',
                'exchange': 'schimbƒÉ',
                'pickup': 'ridicƒÉ',
                'deliver': 'livreazƒÉ',
                'ship': 'expediazƒÉ',
                
                // Time related
                'today': 'astƒÉzi',
                'tomorrow': 'm√¢ine',
                'tonight': '√Æn seara asta',
                'this week': 'sƒÉptƒÉm√¢na aceasta',
                'next week': 'sƒÉptƒÉm√¢na viitoare',
                'urgent task': 'sarcinƒÉ urgentƒÉ',
                'asap': 'c√¢t mai cur√¢nd',
                
                // Common phrases
                'go to': 'du-te la',
                'go to work': 'du-te la muncƒÉ',
                'go home': 'du-te acasƒÉ',
                'pick up': 'ridicƒÉ',
                'drop off': 'lasƒÉ',
                'follow up': 'urmƒÉre»ôte',
                'check in': '√ÆnregistreazƒÉ-te',
                'sign up': '√Ænscrie-te',
                'log in': 'autentificƒÉ-te',
                'back up': 'salveazƒÉ'
            },
            'ro_to_en': {
                '√Ænt√¢lnire': 'meeting',
                'sunƒÉ': 'call',
                'email': 'email',
                'trimite email': 'send email',
                'urgent': 'urgent',
                'important': 'important',
                'termen limitƒÉ': 'deadline',
                'proiect': 'project',
                'sarcinƒÉ': 'task',
                'muncƒÉ': 'work',
                'raport': 'report',
                'prezentare': 'presentation',
                'revizuire': 'review',
                'aprobare': 'approve',
                'completeazƒÉ': 'complete',
                'terminƒÉ': 'finish',
                '√Æncepe': 'start',
                'programeazƒÉ': 'schedule',
                'planificƒÉ': 'plan',
                'organizeazƒÉ': 'organize',
                'pregƒÉte»ôte': 'prepare',
                'trimite': 'submit',
                'fi»ôier': 'file',
                'document': 'document',
                'contract': 'contract',
                'facturƒÉ': 'invoice',
                'buget': 'budget',
                'cheltuialƒÉ': 'expense',
                'propunere': 'proposal',
                'strategie': 'strategy',
                'analizƒÉ': 'analysis',
                'cumpƒÉrƒÉ alimente': 'buy groceries',
                'alimente': 'groceries',
                'cumpƒÉrƒÉturi': 'shopping',
                'cumpƒÉrƒÉ': 'buy',
                'vinde': 'sell',
                'plƒÉte»ôte': 'pay',
                'plƒÉte»ôte facturile': 'pay bills',
                'facturi': 'bills',
                'acasƒÉ': 'home',
                'familie': 'family',
                'copii': 'kids',
                '»ôcoalƒÉ': 'school',
                'temƒÉ': 'homework',
                'curƒÉ»õƒÉ': 'clean',
                'rufe': 'laundry',
                'gƒÉte»ôte': 'cook',
                'cinƒÉ': 'dinner',
                'pr√¢nz': 'lunch',
                'micul dejun': 'breakfast',
                'sunƒÉ doctorul': 'call doctor',
                'du-te la doctor': 'go to the doctor',
                'vezi doctorul': 'see the doctor',
                'viziteazƒÉ doctorul': 'visit doctor',
                'doctor': 'doctor',
                'dentist': 'dentist',
                'programare': 'appointment',
                'spital': 'hospital',
                'farmacie': 'pharmacy',
                'medicament': 'medicine',
                'exerci»õiu': 'exercise',
                'antrenament': 'workout',
                'salƒÉ': 'gym',
                'sƒÉnƒÉtate': 'health',
                'sunƒÉ mama': 'call mom',
                'sunƒÉ tata': 'call dad',
                'mesaj': 'message',
                'rƒÉspunde': 'reply',
                'contacteazƒÉ': 'contact',
                'telefon': 'phone',
                'reparƒÉ': 'fix',
                'actualizeazƒÉ': 'update',
                'anuleazƒÉ': 'cancel',
                'confirmƒÉ': 'confirm',
                'rezervƒÉ': 'book',
                'comandƒÉ': 'order',
                'returneazƒÉ': 'return',
                'schimbƒÉ': 'exchange',
                'ridicƒÉ': 'pickup',
                'livreazƒÉ': 'deliver',
                'expediazƒÉ': 'ship',
                'astƒÉzi': 'today',
                'm√¢ine': 'tomorrow',
                '√Æn seara asta': 'tonight',
                'sƒÉptƒÉm√¢na aceasta': 'this week',
                'sƒÉptƒÉm√¢na viitoare': 'next week',
                'sarcinƒÉ urgentƒÉ': 'urgent task',
                'c√¢t mai cur√¢nd': 'asap',
                'du-te la': 'go to',
                'du-te la muncƒÉ': 'go to work',
                'du-te acasƒÉ': 'go home',
                'lasƒÉ': 'drop off',
                'urmƒÉre»ôte': 'follow up',
                '√ÆnregistreazƒÉ-te': 'check in',
                '√Ænscrie-te': 'sign up',
                'autentificƒÉ-te': 'log in',
                'salveazƒÉ': 'back up'
            }
        };

        // Translation function
        async function translateText(text, targetLang, sourceLang = 'en') {
            try {
                const langMap = {
                    'en': 'en',
                    'ro': 'ro'
                };
                
                const targetCode = langMap[targetLang];
                const sourceCode = langMap[sourceLang];
                
                if (sourceCode === targetCode) {
                    return text;
                }

                // STEP 1: Try dictionary
                const dictKey = `${sourceCode}_to_${targetCode}`;
                const lowerText = text.toLowerCase().trim();
                
                if (dictionary[dictKey] && dictionary[dictKey][lowerText]) {
                    console.log('‚úÖ Dictionary:', text, '‚Üí', dictionary[dictKey][lowerText]);
                    return dictionary[dictKey][lowerText];
                }

                // STEP 2: Word-by-word (ONLY if ALL words translate)
                const words = text.split(' ');
                if (words.length > 1 && words.length <= 5) {
                    const translatedWords = words.map(word => {
                        const lowerWord = word.toLowerCase();
                        return dictionary[dictKey]?.[lowerWord] || null;
                    });
                    
                    if (translatedWords.every(w => w !== null)) {
                        const result = translatedWords.join(' ');
                        console.log('‚úÖ Word-by-word:', text, '‚Üí', result);
                        return result;
                    }
                }

                // STEP 3: API
                try {
                    const response = await fetch(
                        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sourceCode}|${targetCode}`
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.responseData && data.responseData.translatedText) {
                            console.log('‚úÖ API:', text, '‚Üí', data.responseData.translatedText);
                            return data.responseData.translatedText;
                        }
                    }
                } catch (e) {
                    console.log('‚ö†Ô∏è API unavailable');
                }

                console.warn('‚ùå Translation failed:', text);
                return `[${text}]`;
                
            } catch (error) {
                console.error('Translation error:', error);
                return text;
            }
        }

        // UI Translations
        const translations = {
            en: {
                appTitle: "GENIUS Matrix",
                appSubtitle: "Get Every Notable Issue Expertly Sorted",
                exportTasks: "Export",
                importTasks: "Import",
                clearAll: "Clear All",
                clearConfirm: "Clear all tasks?",
                addTask: "Add",
                addTo: "Add to:",
                enterTask: "Enter your task...",
                cancel: "Cancel",
                save: "Save",
                edit: "Edit",
                importSuccess: "Tasks imported!",
                importError: "Error: Invalid file",
                noTasks: "No tasks yet",
                tasksSaved: "Auto-saved ‚Ä¢ Drag to move",
                totalTasks: "total",
                language: "Language",
                translating: "Translating...",
                dragHint: "Long press to drag",
                voiceInput: "üé§ Voice",
                listening: "Listening...",
                speak: "üîä",
                stopSpeaking: "Stop",
                quadrants: {
                    urgent_important: {
                        title: "Do First",
                        subtitle: "Urgent & Important",
                        emoji: "üî•",
                        description: "Critical tasks requiring immediate attention",
                        action: "Do immediately"
                    },
                    not_urgent_important: {
                        title: "Schedule",
                        subtitle: "Not Urgent & Important",
                        emoji: "üìÖ",
                        description: "Strategic work for long-term success",
                        action: "Plan & schedule"
                    },
                    urgent_not_important: {
                        title: "Delegate",
                        subtitle: "Urgent & Not Important",
                        emoji: "üë•",
                        description: "Tasks that can be handled by others",
                        action: "Delegate or minimize"
                    },
                    not_urgent_not_important: {
                        title: "Eliminate",
                        subtitle: "Not Urgent & Not Important",
                        emoji: "üóëÔ∏è",
                        description: "Low-value activities to avoid",
                        action: "Eliminate or defer"
                    }
                }
            },
            ro: {
                appTitle: "Matricea de Decizie GENIUS",
                appSubtitle: "GestioneazƒÉ Eficient Fiecare NotƒÉ ImportantƒÉ »ôi UrgentƒÉ SortatƒÉ",
                exportTasks: "ExportƒÉ Sarcini",
                importTasks: "ImportƒÉ Sarcini",
                clearAll: "»òterge Tot",
                clearConfirm: "Sigur dori»õi sƒÉ »ôterge»õi toate sarcinile? AceastƒÉ ac»õiune nu poate fi anulatƒÉ.",
                addTask: "AdaugƒÉ SarcinƒÉ",
                addTo: "AdaugƒÉ la:",
                enterTask: "Introdu sarcina sau decizia ta...",
                cancel: "AnuleazƒÉ",
                save: "SalveazƒÉ",
                edit: "EditeazƒÉ",
                importSuccess: "Sarcini importate cu succes!",
                importError: "Eroare la import. AsigurƒÉ-te cƒÉ este un fi»ôier JSON valid.",
                noTasks: "Nicio sarcinƒÉ",
                tasksSaved: "Salvat automat ‚Ä¢ Trage pentru a muta",
                totalTasks: "total",
                language: "LimbƒÉ",
                translating: "Se traduce...",
                editTranslation: "Click pentru a edita traducerea",
                dragHint: "ApasƒÉ lung pentru a trage",
                voiceInput: "üé§ Voce",
                listening: "Ascult...",
                speak: "üîä",
                stopSpeaking: "Opre»ôte",
                quadrants: {
                    urgent_important: {
                        title: "FƒÉ Mai √ént√¢i",
                        subtitle: "Urgent »ôi Important",
                        emoji: "üî•",
                        description: "Sarcini critice care necesitƒÉ aten»õie imediatƒÉ",
                        action: "FƒÉ imediat"
                    },
                    not_urgent_important: {
                        title: "ProgrameazƒÉ",
                        subtitle: "Nu Urgent »ôi Important",
                        emoji: "üìÖ",
                        description: "MuncƒÉ strategicƒÉ pentru succes pe termen lung",
                        action: "PlanificƒÉ »ôi programeazƒÉ"
                    },
                    urgent_not_important: {
                        title: "Delege",
                        subtitle: "Urgent »ôi Nu Important",
                        emoji: "üë•",
                        description: "Sarcini care pot fi gestionate de al»õii",
                        action: "Delege sau minimizeazƒÉ"
                    },
                    not_urgent_not_important: {
                        title: "EliminƒÉ",
                        subtitle: "Nu Urgent »ôi Nu Important",
                        emoji: "üóëÔ∏è",
                        description: "ActivitƒÉ»õi de valoare scƒÉzutƒÉ de evitat",
                        action: "EliminƒÉ sau am√¢nƒÉ"
                    }
                }
            }
        };

        // Icons
        const Plus = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        );

        const Trash2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        );

        const Edit2 = ({ size = 18 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
        );

        const Menu = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        );

        const X = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const Download = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const Upload = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const Globe = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="2" y1="12" x2="22" y2="12"></line>
                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
            </svg>
        );

        const Move = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="5 9 2 12 5 15"></polyline>
                <polyline points="9 5 12 2 15 5"></polyline>
                <polyline points="15 19 12 22 9 19"></polyline>
                <polyline points="19 9 22 12 19 15"></polyline>
                <line x1="2" y1="12" x2="22" y2="12"></line>
                <line x1="12" y1="2" x2="12" y2="22"></line>
            </svg>
        );

        const Mic = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        );

        const Volume2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );

        function DecisionMatrix() {
            const [tasks, setTasks] = useState([]);
            const [newTask, setNewTask] = useState('');
            const [selectedQuadrant, setSelectedQuadrant] = useState(null);
            const [showMenu, setShowMenu] = useState(false);
            const [language, setLanguage] = useState('en');
            const [uiLanguage, setUiLanguage] = useState('en'); // UI language toggle
            const [isTranslating, setIsTranslating] = useState(false);
            const [editingTask, setEditingTask] = useState(null);
            const [editText, setEditText] = useState('');
            const [draggedTask, setDraggedTask] = useState(null);
            const [dragOverQuadrant, setDragOverQuadrant] = useState(null);
            const [dragOverTask, setDragOverTask] = useState(null);
            const [touchStartY, setTouchStartY] = useState(null);
            const [touchCurrentY, setTouchCurrentY] = useState(null);
            const [isListening, setIsListening] = useState(false);
            const [isSpeaking, setIsSpeaking] = useState(false);
            const recognitionRef = React.useRef(null); // Persistent voice recognition

            // Initialize recognition once
            React.useEffect(() => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SpeechRecognition && !recognitionRef.current) {
                    const recognition = new SpeechRecognition();
                    recognition.lang = 'en-US';
                    recognition.interimResults = true;
                    recognition.continuous = false;

                    recognition.onstart = () => {
                        setIsListening(true);
                        console.log('‚úÖ Voice started');
                    };

                    recognition.onresult = (event) => {
                        const results = event.results;
                        const lastIndex = results.length - 1;
                        const transcript = results[lastIndex][0].transcript;
                        console.log('‚úÖ Voice:', transcript);
                        setNewTask(transcript);
                        if (results[lastIndex].isFinal) {
                            setIsListening(false);
                        }
                    };

                    recognition.onerror = (event) => {
                        console.error('‚ùå Voice error:', event.error);
                        setIsListening(false);
                    };

                    recognition.onend = () => {
                        setIsListening(false);
                        console.log('üèÅ Voice ended');
                    };

                    recognitionRef.current = recognition;
                }
            }, []);

            useEffect(() => {
                const saved = localStorage.getItem('geniusTasks');
                if (saved) {
                    const loadedTasks = JSON.parse(saved);
                    // Initialize order for tasks that don't have it
                    const tasksWithOrder = loadedTasks.map((task, index) => {
                        if (task.order === undefined) {
                            const quadrantTasks = loadedTasks.filter(t => t.quadrant === task.quadrant);
                            const orderInQuadrant = quadrantTasks.indexOf(task);
                            return { ...task, order: orderInQuadrant };
                        }
                        return task;
                    });
                    setTasks(tasksWithOrder);
                } else {
                    setTasks([]);
                }
                const savedLang = localStorage.getItem('geniusLanguage');
                if (savedLang) {
                    setLanguage(savedLang);
                }
            }, []);

            useEffect(() => {
                localStorage.setItem('geniusTasks', JSON.stringify(tasks));
            }, [tasks]);

            useEffect(() => {
                localStorage.setItem('geniusLanguage', language);
            }, [language]);

            useEffect(() => {
                const translateAllTasks = async () => {
                    if (tasks.length === 0) return;
                    
                    setIsTranslating(true);
                    
                    const translatedTasks = await Promise.all(
                        tasks.map(async (task) => {
                            if (!task.translations || !task.translations[language]) {
                                const sourceLang = task.sourceLang || 'en';
                                const sourceText = task.translations?.[sourceLang] || task.text;
                                const translated = await translateText(sourceText, language, sourceLang);
                                
                                return {
                                    ...task,
                                    translations: {
                                        ...task.translations,
                                        [language]: translated
                                    }
                                };
                            }
                            return task;
                        })
                    );
                    
                    setTasks(translatedTasks);
                    setIsTranslating(false);
                };
                
                translateAllTasks();
            }, [language]);

            const t = translations[uiLanguage]; // Use uiLanguage for buttons/interface

            // Voice Recognition
            const startVoiceInput = async () => {
                if (!recognitionRef.current) {
                    alert('Voice recognition not supported. Try Chrome, Edge, or Safari.');
                    return;
                }

                if (isListening) {
                    console.log('Already listening...');
                    return;
                }

                try {
                    recognitionRef.current.lang = language === 'en' ? 'en-US' : 'ro-RO';
                    try {
                        recognitionRef.current.abort();
                    } catch (e) {
                        // Ignore
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                    recognitionRef.current.start();
                    console.log('üé§ Voice started');
                } catch (err) {
                    console.error('Voice error:', err);
                    alert('Could not start voice. Try again.');
                }
            };

            // Text to Speech
            // Speak functions for dual language
            const speakEN = (text) => {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'en-US';
                    window.speechSynthesis.speak(utterance);
                }
            };

            const speakRO = (text) => {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'ro-RO';
                    window.speechSynthesis.speak(utterance);
                }
            };

            const quadrants = {
                urgent_important: {
                    ...t.quadrants.urgent_important,
                    color: 'bg-red-50 border-red-300',
                    headerColor: 'bg-red-500'
                },
                not_urgent_important: {
                    ...t.quadrants.not_urgent_important,
                    color: 'bg-blue-50 border-blue-300',
                    headerColor: 'bg-blue-500'
                },
                urgent_not_important: {
                    ...t.quadrants.urgent_not_important,
                    color: 'bg-yellow-50 border-yellow-300',
                    headerColor: 'bg-yellow-500'
                },
                not_urgent_not_important: {
                    ...t.quadrants.not_urgent_not_important,
                    color: 'bg-gray-50 border-gray-300',
                    headerColor: 'bg-gray-500'
                }
            };

            const addTask = async (quadrantId) => {
                if (newTask.trim()) {
                    const newTaskObj = {
                        id: Date.now(),
                        text: newTask,
                        quadrant: quadrantId,
                        order: tasks.filter(t => t.quadrant === quadrantId).length,
                        createdAt: new Date().toISOString(),
                        translations: {
                            en: newTask,
                            ro: '[Translating...]'
                        },
                        sourceLang: 'en'
                    };
                    
                    setTasks([...tasks, newTaskObj]);
                    setNewTask('');
                    setSelectedQuadrant(null);
                    
                    // Translate to Romanian
                    const roTranslation = await translateText(newTask, 'ro', 'en');
                    setTasks(prev => prev.map(t => 
                        t.id === newTaskObj.id 
                            ? { ...t, translations: { en: newTask, ro: roTranslation } }
                            : t
                    ));
                }
            };
                        ));
                    }
                }
            };

            const deleteTask = (taskId) => {
                setTasks(tasks.filter(t => t.id !== taskId));
            };

            const startEditTask = (task) => {
                setEditingTask(task.id);
                setEditText(task.translations?.[language] || task.text);
            };

            const saveEditTask = (taskId) => {
                setTasks(prev => prev.map(t => 
                    t.id === taskId 
                        ? { ...t, translations: { ...t.translations, [language]: editText } }
                        : t
                ));
                setEditingTask(null);
                setEditText('');
            };

            const cancelEdit = () => {
                setEditingTask(null);
                setEditText('');
            };

            // Touch event handlers for mobile
            const handleTouchStart = (e, task) => {
                console.log('Touch start on:', task.text);
                setDraggedTask(task);
                setTouchStartY(e.touches[0].clientY);
                e.currentTarget.style.opacity = '0.5';
            };

            const handleTouchMove = (e, quadrantId) => {
                if (!draggedTask) return;
                
                e.preventDefault();
                setTouchCurrentY(e.touches[0].clientY);
                
                // Find which element we're over
                const touch = e.touches[0];
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Check if we're over a task
                const taskElement = elementBelow?.closest('[data-task-id]');
                if (taskElement) {
                    const taskId = parseInt(taskElement.getAttribute('data-task-id'));
                    const overTask = tasks.find(t => t.id === taskId);
                    if (overTask && overTask.id !== draggedTask.id) {
                        console.log('Over task:', overTask.text);
                        setDragOverTask(overTask);
                        setDragOverQuadrant(overTask.quadrant);
                        return;
                    }
                }
                
                // Check if we're over a quadrant
                const quadrantElement = elementBelow?.closest('[data-quadrant]');
                if (quadrantElement) {
                    const quadrant = quadrantElement.getAttribute('data-quadrant');
                    console.log('Over quadrant:', quadrant);
                    setDragOverQuadrant(quadrant);
                    setDragOverTask(null);
                } else {
                    setDragOverTask(null);
                }
            };

            const handleTouchEnd = (e, quadrantId) => {
                console.log('Touch end');
                if (!draggedTask) return;
                
                e.currentTarget.style.opacity = '1';
                
                let newTasks = [...tasks];
                let orderUpdated = false;
                
                // Case 1: Reorder within same quadrant
                if (dragOverTask && draggedTask.quadrant === dragOverTask.quadrant) {
                    console.log('Reordering within quadrant (touch)');
                    const quadrantTasks = newTasks
                        .filter(t => t.quadrant === dragOverTask.quadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    const draggedIndex = quadrantTasks.findIndex(t => t.id === draggedTask.id);
                    const targetIndex = quadrantTasks.findIndex(t => t.id === dragOverTask.id);
                    
                    console.log('Touch indexes:', { draggedIndex, targetIndex });
                    
                    const [removed] = quadrantTasks.splice(draggedIndex, 1);
                    quadrantTasks.splice(targetIndex, 0, removed);
                    
                    console.log('Touch new order:', quadrantTasks.map(t => t.text));
                    
                    quadrantTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                    
                    orderUpdated = true;
                }
                // Case 2: Move to different quadrant
                else if (dragOverQuadrant && draggedTask.quadrant !== dragOverQuadrant) {
                    console.log('Moving to different quadrant (touch)');
                    
                    // First, update the dragged task's quadrant
                    const targetQuadrantTasks = newTasks.filter(t => t.quadrant === dragOverQuadrant && t.id !== draggedTask.id);
                    const newOrder = dragOverTask 
                        ? targetQuadrantTasks.findIndex(t => t.id === dragOverTask.id)
                        : targetQuadrantTasks.length;
                    
                    newTasks = newTasks.map(t => 
                        t.id === draggedTask.id 
                            ? { ...t, quadrant: dragOverQuadrant, order: newOrder }
                            : t
                    );
                    
                    // Reorder source quadrant
                    const sourceQuadrantTasks = newTasks
                        .filter(t => t.quadrant === draggedTask.quadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    sourceQuadrantTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                    
                    // Reorder target quadrant
                    const updatedTargetTasks = newTasks
                        .filter(t => t.quadrant === dragOverQuadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    updatedTargetTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                    
                    orderUpdated = true;
                }
                
                if (orderUpdated) {
                    console.log('Saving updated task order');
                    setTasks(newTasks);
                }
                
                setDraggedTask(null);
                setDragOverTask(null);
                setDragOverQuadrant(null);
                setTouchStartY(null);
                setTouchCurrentY(null);
            };

            // Drag and drop handlers (for desktop/mouse)
            const handleDragStart = (e, task) => {
                setDraggedTask(task);
                e.currentTarget.classList.add('dragging');
            };

            const handleDragEnd = (e) => {
                e.currentTarget.classList.remove('dragging');
                setDraggedTask(null);
                setDragOverQuadrant(null);
                setDragOverTask(null);
            };

            const handleDragOver = (e, quadrantId, overTask = null) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                setDragOverQuadrant(quadrantId);
                setDragOverTask(overTask);
            };

            const handleDragLeave = () => {
                setDragOverQuadrant(null);
                setDragOverTask(null);
            };

            const handleDrop = (e, targetQuadrant, targetTask = null) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (!draggedTask) {
                    console.log('No dragged task');
                    return;
                }

                console.log('Drop triggered:', {
                    draggedTask: draggedTask.text,
                    targetQuadrant,
                    targetTask: targetTask?.text || 'quadrant bottom',
                    sameQuadrant: draggedTask.quadrant === targetQuadrant
                });

                let newTasks = [...tasks];
                
                if (targetTask && draggedTask.quadrant === targetQuadrant) {
                    // Reorder within same quadrant
                    console.log('Reordering within quadrant');
                    const quadrantTasks = newTasks
                        .filter(t => t.quadrant === targetQuadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    const draggedIndex = quadrantTasks.findIndex(t => t.id === draggedTask.id);
                    const targetIndex = quadrantTasks.findIndex(t => t.id === targetTask.id);
                    
                    console.log('Indexes:', { draggedIndex, targetIndex });
                    
                    // Remove dragged task
                    const [removed] = quadrantTasks.splice(draggedIndex, 1);
                    // Insert at target position
                    quadrantTasks.splice(targetIndex, 0, removed);
                    
                    console.log('New order:', quadrantTasks.map(t => t.text));
                    
                    // Update order for all tasks in this quadrant
                    quadrantTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                } else if (draggedTask.quadrant !== targetQuadrant) {
                    // Move to different quadrant
                    console.log('Moving to different quadrant');
                    const targetQuadrantTasks = newTasks.filter(t => t.quadrant === targetQuadrant);
                    const newOrder = targetTask 
                        ? targetQuadrantTasks.findIndex(t => t.id === targetTask.id)
                        : targetQuadrantTasks.length;
                    
                    // Update moved task
                    newTasks = newTasks.map(t => 
                        t.id === draggedTask.id 
                            ? { ...t, quadrant: targetQuadrant, order: newOrder }
                            : t
                    );
                    
                    // Reorder all tasks in target quadrant
                    const updatedTargetTasks = newTasks
                        .filter(t => t.quadrant === targetQuadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    updatedTargetTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                }
                
                console.log('Updating tasks state');
                setTasks(newTasks);
                setDraggedTask(null);
                setDragOverQuadrant(null);
                setDragOverTask(null);
            };

            const getTasksByQuadrant = (quadrantId) => {
                return tasks
                    .filter(t => t.quadrant === quadrantId)
                    .sort((a, b) => (a.order || 0) - (b.order || 0));
            };

            const getTaskText = (task) => {
                return task.translations?.[language] || task.text;
            };

            const exportData = () => {
                const dataStr = JSON.stringify(tasks, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `genius-matrix-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                setShowMenu(false);
            };

            const importData = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const imported = JSON.parse(e.target.result);
                            setTasks(imported);
                            alert(t.importSuccess);
                        } catch (error) {
                            alert(t.importError);
                        }
                    };
                    reader.readAsText(file);
                }
                setShowMenu(false);
            };

            const clearAllTasks = () => {
                if (confirm(t.clearConfirm)) {
                    setTasks([]);
                }
                setShowMenu(false);
            };

            const languageNames = {
                en: 'EN', ro: 'RO'
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-100 to-slate-200">
                    <div className="bg-slate-800 text-white p-4 sticky top-0 z-40 shadow-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h1 className="text-xl font-bold">{t.appTitle}</h1>
                                <p className="text-xs text-slate-300">{t.appSubtitle}</p>
                                {isTranslating && (
                                    <p className="text-xs text-blue-300 mt-1">{t.translating}</p>
                                )}
                            </div>
                            <button
                                onClick={() => setShowMenu(!showMenu)}
                                className="p-2 hover:bg-slate-700 rounded-lg transition-colors"
                            >
                                {showMenu ? <X /> : <Menu />}
                            </button>
                        </div>
                    </div>

                    {showMenu && (
                        <div className="bg-white border-b-2 border-slate-200 p-4 space-y-2 shadow-lg">
                            <div className="bg-blue-50 border-2 border-blue-300 rounded-lg p-3 mb-2">
                                <div className="text-center mb-2">
                                    <p className="text-sm font-bold text-blue-800">üåç Dual Language Tasks</p>
                                    <p className="text-xs text-blue-600">English + Rom√¢nƒÉ</p>
                                </div>
                                <div className="flex items-center justify-center gap-2 mt-2">
                                    <span className="text-xs text-slate-600">UI Language:</span>
                                    <button
                                        onClick={() => setUiLanguage('en')}
                                        className={`px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            uiLanguage === 'en' ? 'bg-blue-500 text-white' : 'bg-white text-slate-600 border-2'
                                        }`}
                                    >
                                        EN
                                    </button>
                                    <button
                                        onClick={() => setUiLanguage('ro')}
                                        className={`px-3 py-1 rounded-lg text-sm font-medium transition-colors ${
                                            uiLanguage === 'ro' ? 'bg-blue-500 text-white' : 'bg-white text-slate-600 border-2'
                                        }`}
                                    >
                                        RO
                                    </button>
                                </div>
                            </div>
                            <div className="flex gap-2">
                            <button
                                onClick={exportData}
                                className="w-full p-3 bg-blue-500 text-white rounded-lg flex items-center justify-center gap-2 font-medium active:bg-blue-600"
                            >
                                <Download />
                                {t.exportTasks}
                            </button>
                            <label className="w-full p-3 bg-green-500 text-white rounded-lg flex items-center justify-center gap-2 font-medium active:bg-green-600 cursor-pointer">
                                <Upload />
                                {t.importTasks}
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={importData}
                                    className="hidden"
                                />
                            </label>
                            <button
                                onClick={clearAllTasks}
                                className="w-full p-3 bg-red-500 text-white rounded-lg font-medium active:bg-red-600"
                            >
                                {t.clearAll}
                            </button>
                        </div>
                    )}

                    <div className="p-4 pb-20 space-y-4">
                        {Object.entries(quadrants).map(([key, quadrant]) => (
                            <div
                                key={key}
                                data-quadrant={key}
                                className={`${quadrant.color} border-2 rounded-xl shadow-lg overflow-hidden transition-all ${
                                    dragOverQuadrant === key ? 'drag-over' : ''
                                }`}
                                onDragOver={(e) => handleDragOver(e, key)}
                                onDragLeave={handleDragLeave}
                                onDrop={(e) => handleDrop(e, key)}
                            >
                                <div className={`${quadrant.headerColor} text-white p-4`}>
                                    <div className="flex items-center gap-2 mb-1">
                                        <span className="text-2xl">{quadrant.emoji}</span>
                                        <h2 className="text-xl font-bold">{quadrant.title}</h2>
                                    </div>
                                    <p className="text-xs opacity-90">{quadrant.subtitle}</p>
                                </div>

                                <div className="p-4">
                                    <div className="bg-white rounded-lg px-3 py-2 mb-3 text-sm font-semibold text-slate-700">
                                        ‚Üí {quadrant.action}
                                    </div>

                                    <div className="space-y-2 mb-3 max-h-[300px] overflow-y-auto">
                                        {getTasksByQuadrant(key).length === 0 ? (
                                            <div className="text-center py-4 text-slate-400 text-sm italic">
                                                {t.noTasks}
                                            </div>
                                        ) : (
                                            getTasksByQuadrant(key).map(task => (
                                                <div
                                                    key={task.id}
                                                    data-task-id={task.id}
                                                    draggable={editingTask !== task.id}
                                                    onDragStart={(e) => handleDragStart(e, task)}
                                                    onDragEnd={handleDragEnd}
                                                    onDragOver={(e) => handleDragOver(e, key, task)}
                                                    onDrop={(e) => handleDrop(e, key, task)}
                                                    onTouchStart={(e) => handleTouchStart(e, task)}
                                                    onTouchMove={(e) => handleTouchMove(e, key)}
                                                    onTouchEnd={(e) => handleTouchEnd(e, key)}
                                                    className={`bg-white rounded-lg p-3 shadow-sm flex items-center gap-2 ${
                                                        isTranslating ? 'translating' : ''
                                                    } ${draggedTask?.id === task.id ? 'dragging' : ''} ${
                                                        dragOverTask?.id === task.id ? 'border-t-2 border-blue-500' : ''
                                                    }`}
                                                >
                                                    {editingTask !== task.id && (
                                                        <div className="text-slate-400">
                                                            <Move size={16} />
                                                        </div>
                                                    )}
                                                    
                                                    {editingTask === task.id ? (
                                                        <div className="flex-1 flex flex-col gap-2">
                                                            <input
                                                                type="text"
                                                                value={editText}
                                                                onChange={(e) => setEditText(e.target.value)}
                                                                className="w-full px-2 py-1 border border-blue-300 rounded text-sm focus:outline-none focus:border-blue-500"
                                                                autoFocus
                                                            />
                                                            <div className="flex gap-2">
                                                                <button
                                                                    onClick={() => saveEditTask(task.id)}
                                                                    className="flex-1 text-green-600 bg-green-50 py-1 rounded text-sm font-medium"
                                                                >
                                                                    {t.save}
                                                                </button>
                                                                <button
                                                                    onClick={cancelEdit}
                                                                    className="flex-1 text-gray-600 bg-gray-50 py-1 rounded text-sm font-medium"
                                                                >
                                                                    {t.cancel}
                                                                </button>
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        <>
                                                            <div className="flex-1">
                                                                <div className="flex items-center gap-1 mb-1">
                                                                    <span className="text-xs text-blue-600 font-bold">EN:</span>
                                                                    <span className="text-sm text-slate-700 flex-1">{task.translations?.en || task.text}</span>
                                                                    <button
                                                                        onClick={() => speakEN(task.translations?.en || task.text)}
                                                                        className="text-green-500 p-1"
                                                                    >
                                                                        <Volume2 size={18} />
                                                                    </button>
                                                                </div>
                                                                <div className="flex items-center gap-1">
                                                                    <span className="text-xs text-red-600 font-bold">RO:</span>
                                                                    <span className="text-sm text-slate-700 flex-1">{task.translations?.ro || '[...]'}</span>
                                                                    <button
                                                                        onClick={() => speakRO(task.translations?.ro || task.text)}
                                                                        className="text-green-500 p-1"
                                                                    >
                                                                        <Volume2 size={18} />
                                                                    </button>
                                                                </div>
                                                            </div>
                                                            <div className="flex flex-col gap-1">
                                                                <button
                                                                    onClick={() => startEditTask(task)}
                                                                    className="text-blue-500 p-1"
                                                                >
                                                                    <Edit2 size={16} />
                                                                </button>
                                                                <button
                                                                    onClick={() => deleteTask(task.id)}
                                                                    className="text-red-500 p-1"
                                                                >
                                                                    <Trash2 size={16} />
                                                                </button>
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            ))
                                        )}
                                    </div>

                                    <button
                                        onClick={() => setSelectedQuadrant(key)}
                                        className="w-full py-3 px-4 bg-white border-2 border-dashed border-slate-300 rounded-lg text-slate-600 active:bg-slate-50 transition-all flex items-center justify-center gap-2 font-medium"
                                    >
                                        <Plus size={20} />
                                        <span>{t.addTask}</span>
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>

                    {selectedQuadrant && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-end justify-center z-50">
                            <div className="bg-white rounded-t-2xl w-full max-h-[80vh] overflow-y-auto">
                                <div className="p-5">
                                    <div className="flex items-center gap-2 mb-3">
                                        <span className="text-3xl">{quadrants[selectedQuadrant].emoji}</span>
                                        <div>
                                            <h3 className="text-xl font-bold text-slate-800">
                                                {quadrants[selectedQuadrant].title}
                                            </h3>
                                            <p className="text-xs text-slate-600">
                                                {quadrants[selectedQuadrant].description}
                                            </p>
                                        </div>
                                    </div>
                                    <textarea
                                        value={newTask}
                                        onChange={(e) => setNewTask(e.target.value)}
                                        placeholder={t.enterTask}
                                        className="w-full px-4 py-3 border-2 border-slate-300 rounded-lg focus:outline-none focus:border-blue-500 mb-3 resize-none text-base"
                                        rows="4"
                                        autoFocus
                                    />
                                    <button
                                        onClick={startVoiceInput}
                                        disabled={isListening}
                                        className={`w-full mb-4 py-3 px-4 rounded-lg flex items-center justify-center gap-2 text-base font-medium transition-colors ${
                                            isListening 
                                                ? 'bg-red-500 text-white animate-pulse' 
                                                : 'bg-purple-500 text-white active:bg-purple-600'
                                        }`}
                                    >
                                        <Mic size={24} />
                                        {isListening ? 'üî¥ ' + t.listening : t.voiceInput}
                                    </button>
                                    {isListening && (
                                        <div className="mb-4 p-3 bg-yellow-100 border-2 border-yellow-400 rounded-lg text-sm">
                                            üé§ <strong>Listening...</strong> Speak now! Your speech will appear above.
                                        </div>
                                    )}
                                    <div className="space-y-3">
                                        <button
                                            onClick={() => addTask(selectedQuadrant)}
                                            className="w-full bg-blue-500 text-white py-4 px-4 rounded-lg active:bg-blue-600 transition-colors font-medium text-lg"
                                        >
                                            {t.addTask}
                                        </button>
                                        <button
                                            onClick={() => {
                                                setSelectedQuadrant(null);
                                                setNewTask('');
                                            }}
                                            className="w-full bg-slate-200 text-slate-700 py-4 px-4 rounded-lg active:bg-slate-300 transition-colors font-medium text-lg"
                                        >
                                            {t.cancel}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 p-3 text-center text-xs text-slate-500">
                        {t.tasksSaved} ‚Ä¢ {tasks.length} {t.totalTasks}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<DecisionMatrix />, document.getElementById('root'));
    </script>
</body>
</html>
